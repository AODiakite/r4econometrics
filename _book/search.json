[{"path":"index.html","id":"bienvenue","chapter":"Bienvenue","heading":"Bienvenue","text":"Au cours des dernières années, le langage de programmation statistique R est devenu une partie intégrante des programmes des cours d’économétrie. Nous avons régulièrement constaté qu’une grande partie des étudiants, en particulier dans nos cours d’introduction à l’économétrie de premier cycle, n’ont jamais été exposés à aucun langage de programmation et ont donc des difficultés à s’engager seuls dans l’apprentissage de R. Avec peu d’expérience en statistiques et en économétrie, il est naturel que les débutants aient du mal à comprendre les avantages d’avoir des compétences en R pour apprendre et appliquer l’économétrie. Celles-ci incluent en particulier la capacité de mener, de documenter et de communiquer des études empiriques et d’avoir les installations nécessaires pour programmer des études de simulation, ce qui est utile, par exemple, pour comprendre et valider des théorèmes qui ne sont généralement pas facilement saisis en ruminant simplement sur des formules. En tant qu’économistes appliqués et économètres, tous ces derniers sont des capacités que nous apprécions et que nous souhaitons partager.Il s’agit d’un script interactif dans le style d’un rapport de recherche reproductible et permet aux étudiants non seulement d’apprendre comment les résultats d’études de cas peuvent être reproduits avec R, mais renforce également leur capacité à utiliser les compétences nouvellement acquises dans d’autres applications empiriques.","code":""},{"path":"intro1.html","id":"intro1","chapter":"1 Introduction","heading":"1 Introduction","text":"R est un langage de programmation créé par les staticiens Ross Ihaka et Robert Gentleman.\nC’est un langage dédié aux statistiques, représentations graphiques, ainsi que tout ce qui se rattache au traitement et manipulation de données. C’est aussi un logiciel à accès libre (open-source) disponible sous la licence publique générale GNU (GNU General Public License).Principalement écrit en C et Fortran, R est une implémentation du langage S qui supporte plusieurs paradigmes de programmation tel que : procédural, orienté objet, fonctionnel, réflexif, impératif, tableau.Depuis sa création, le langage fortement évolué grâce à la contribution de sa communauté d’utilisateurs notamment par la publications de packages et de tutoriels. Cette évolution permis d’étendre les fonctionnalités de ce langage à la rédaction d’ouvrage avec bookdown, d’article et de présentations avec R markdown, à la représentation graphique avec ggplot2 etc.\nRien que sur le CRAN (Comprehensive R Archive Network) peut trouver plus de 18000 packages.Dans le chapitre suivant nous allons voir les bases de la programmation avec R en utilisant le logiciel RStudio.","code":""},{"path":"base.html","id":"base","chapter":"2 les bases","heading":"2 les bases","text":"l’instar des autres langages, R besoin d’un environnement de développement intégré (IDE) pour être utilisé. En plus d’une console interactive, l’IDE propose plusieurs fonctionnalités. Nous en verrons quelques-unes plus tard.\nR est intégré par plusieurs logiciels tels que R lui-même, IntelliJ IDE, Rcode etc. Tout au long de cet ouvrage nous n’utiliserons que RStudio qui est l’un des IDE les plus célèbres de R.","code":""},{"path":"base.html","id":"interface","chapter":"2 les bases","heading":"2.1 Interface","text":"\nL’interface RStudio se présente ainsi par défaut. Nous pouvons voir une console, un environnement de travail, une partie pour les scripts et une autre pour la visualisation des graphiques.La console peut servir à écrire une ligne d’instruction qui sera exécutée en appuyant sur Entrer.La partie dédiée au scripts permet d’écrire un ensemble de lignes de codes qui peuvent être exécutées par ordre voulu par l’utilisateur. En plus des scripts, peut y visualiser nos tableaux de données qui sont décrits dans la section 2.3.5.Les graphes peuvent être visibles dans la partie Plots de notre interface. Cette partie est un panneau contenant les onglets Viewer pour les pages html, Files pour naviguer dans les fichiers, Packages pour gérer les packages installés et Help pour chercher de l’aide.La dernière partie c’est à dire Environment est consacrée à la gestion de l’environnement de travail. Elle permet de voir les variables créés lors de notre session mais aussi d’avoir une idée sur leur structure","code":""},{"path":"base.html","id":"firstcode","chapter":"2 les bases","heading":"2.2 Premiers codes","text":"Et si écrivait notre premier code ?\nDans la section précédente nous avons présenté brièvement l’interface de RStudio, place maintenant à notre première instruction. Commencez par effectuer une petite opération d’addition (2+3) sur votre console puis appuyez sur Entrer.Le résultat obtenu est tout naturellement 5. Vous constatez que [1] précède le résultat de l’opération, en effet l’affichage se fait par défaut sous forme d’une liste2.3.3.\nLa console peut être utilisée comme une calculatrice et supporte toutes les opérations arithmétiques telles que la soustraction(-), l’addition(+), la multiplication(*), la division décimale(/), la division entière(%/%), le modulo1 (%%).\nLe symbole (#) sert à écrire une ligne de commentaire.peut aussi effectuer des assignations sans déclarer les variables au préalable comme l’indique le code suivant.","code":"\n2+3\n#> [1] 5\n1+2 #addition\n\n1-2 #Soustraction\n\n1/2 #Division decimale\n\n1%/%2 #Division entiere\n\n1%%2 #Modulo\nx = 1 #affection de la valeur 1 à x\ny <- 2 #affection de la valeur 2 à y\nx+y #somme de x et y (1+2)\n#> [1] 3"},{"path":"base.html","id":"data-R","chapter":"2 les bases","heading":"2.3 Données sur R","text":"Il existe 6 principaux types simples de données sur R sont : logical, integer, double, complex, character, raw.\nIl arrive qu’une structure de données se compose de types simples données, c’est ce que nous allons étudier dans cette section.","code":""},{"path":"base.html","id":"vecteur","chapter":"2 les bases","heading":"2.3.1 Vecteur","text":"","code":""},{"path":"base.html","id":"définition","chapter":"2 les bases","heading":"Définition","text":"Le vecteur est un objet de base de R qui correspond à une liste d’éléments. Ses propriétés fondamentales sont :Dimension unitaire (les vecteurs sont unidimensionnel)Éléments de même type (Toutes les valeurs contenues dans un vecteur sont de même type)Longueur égale au nombre d’éléments","code":""},{"path":"base.html","id":"création","chapter":"2 les bases","heading":"Création","text":"La fonction la plus classique pour créer un vecteur est c(...). Elle prend comme argument les éléments du vecteur. Dans le code suivant, nous allons créer un vecteur contenant les valeurs de 1 jusqu’à 5 puis nous allons le nommer myvectorMaintenant que nous avons un vecteur, il est naturel de se demander comment accéder aux éléments de ce dernier. Facile ! Il suffit de mettre entre crochet ([]), juste après le nom de votre vecteur, l’indice de l’élément voulu sachant que sur R le comptage commence par 1 au lieu de 0. Par exemple, dans la cellule suivante, le code permet d’afficher le quatrième élément c’est-à-dire celui qui pour indice 4 de myvector.Vous pouvez aussi supprimer un élément d’un vecteur en essayant de l’afficher avec l’opposé de son indice. Supprimons le premier élément de myvector !Il se peut qu’veuille créer une séquence de valeurs avec un pas spécifié. Un exemple concret c’est de vouloir créer un vecteur nommé evenVector contenant tous les nombres pairs compris entre 0 et 100. L’utilisation de la fonction c() rendrait le travail fastidieux. La fonction seq() est plus adaptée à notre situation. Elle prend comme argument (le début de la séquence), (la fin de la séquence), (le pas de la séquence), etc. Pour en savoir plus vous pouvez exécuter la commande ?seq().Si le pas de la séquence est de 1, peut utiliser à la place de seq() l’opérateur : de premier terme le début de la séquence et de second terme la fin de la séquence. L’exemple qui suit permet de créer le vecteur myvector contenant tous les entiers de 1 à 5.Il est possible de créer un vecteur d’éléments répétitifs avec la fonction rep(). Supposons que nous voulons créer le vecteur repvector contenant 5 fois de suite tous les entiers de 1 à 10, nous allons donner en premier argument à la fonction rep() l’objet à répéter (1:10) et comme second argument le nombre de répétitions(5).","code":"\nmyvector <- c(1,2,3,4,5) #Création\nmyvector #Affichage\n#> [1] 1 2 3 4 5\nmyvector[4]\n#> [1] 4\nmyvector[-1]\n#> [1] 2 3 4 5\nevenVector <- seq(from = 0, to = 100, by = 2) #Création \nevenVector #Affichage\n#>  [1]   0   2   4   6   8  10  12  14  16  18  20  22  24  26\n#> [15]  28  30  32  34  36  38  40  42  44  46  48  50  52  54\n#> [29]  56  58  60  62  64  66  68  70  72  74  76  78  80  82\n#> [43]  84  86  88  90  92  94  96  98 100\nmyvector <- 1:5\nmyvector\n#> [1] 1 2 3 4 5\nrepvector <- rep(1:10,5)\nrepvector\n#>  [1]  1  2  3  4  5  6  7  8  9 10  1  2  3  4  5  6  7  8\n#> [19]  9 10  1  2  3  4  5  6  7  8  9 10  1  2  3  4  5  6\n#> [37]  7  8  9 10  1  2  3  4  5  6  7  8  9 10"},{"path":"base.html","id":"facteur","chapter":"2 les bases","heading":"2.3.2 Facteur","text":"","code":""},{"path":"base.html","id":"définition-1","chapter":"2 les bases","heading":"Définition","text":"Le facteur (factor) est un vecteur de valeurs d’une variable catégorielle. Très souvevent, les variables qualitatives sont catégorielles c’est le cas du sexe(Homme, Femme), des questions directes(Oui, Non), etc.C’est d’ailleurs la raison de l’existance de cet objet sur R qui est très utiles dans certaines representations graphiques.Le caractère principal de factor est qu’il dispose de niveaux appelés levels. Ces derniers sont uniques et peuvent avoir des valeurs qui ne sont pas contenus par le facteur.","code":""},{"path":"base.html","id":"création-1","chapter":"2 les bases","heading":"Création","text":"Pour créer un facteur, commence par créer un vecteur puis avec la fonction factor() nous pouvons le transformer en objet de type facteur. Par défaut, les niveaux des facteurs sont les modalités prises par le vecteur. Pour modifier les niveaux utilise l’argument levels de la fonction factor() pour spécifier notre vecteur de niveaux.\nse propose de transformer en facteur le vecteur animal de modalités chat, souris, chien en un facteur de niveaux chat, souris, chien et rat.","code":"\nanimal <- c(\"souris\",\"souris\",\"chien\",\"chat\",\"chien\",\"chat\",\"souris\",\"chat\",\"chat\",\"chien\")\nmyfactor <- factor(animal,levels = c('chat','souris','chien','rat'))\nmyfactor\n#>  [1] souris souris chien  chat   chien  chat   souris chat  \n#>  [9] chat   chien \n#> Levels: chat souris chien rat"},{"path":"base.html","id":"list","chapter":"2 les bases","heading":"2.3.3 Liste","text":"","code":""},{"path":"base.html","id":"définition-2","chapter":"2 les bases","heading":"Définition","text":"Une liste est un objet pouvant contenir des éléments de tous types. L’homogénéité du type des éléments n’est pas obligatoire dans une liste c’est à dire qu’elle peut contenir des listes, des vecteurs, des matrices, des fonctions etc. peut nommer les éléments d’une liste lors de sa création en effectuant des affections.","code":""},{"path":"base.html","id":"création-2","chapter":"2 les bases","heading":"Création","text":"La création d’une liste se fait avec la fonction list() qui prend en argument les éléments à concaténer.peut accéder à un élément par son nom en utilisant le symbole $ (malist$nomElement). L’accès à l’élément num de mylist peut se faire de la manière suivante :Un autre moyen d’accéder à un élément d’une liste c’est par son indice mis entre deux crochets ([[index]]) juste après le nom de la liste. peut reprendre l’accès à l’élément num par indexation.peut modifier l’élément num de mylist en lui affectant une nouvelle valeur.L’ajout d’un nouvel élément dans mylist peut aussi se faire facilement. Si se propose d’ajouter un élément nommé logical qui reçoit initialement TRUE peut procéder ainsi :","code":"\nmylist = list(num = c(1,2,3), char = 'character')\nmylist\n#> $num\n#> [1] 1 2 3\n#> \n#> $char\n#> [1] \"character\"\nmylist$num\n#> [1] 1 2 3\nmylist[[1]]\n#> [1] 1 2 3\nmylist$num = 1:10\nmylist$num\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nmylist$logical = TRUE\nmylist\n#> $num\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n#> \n#> $char\n#> [1] \"character\"\n#> \n#> $logical\n#> [1] TRUE"},{"path":"base.html","id":"matrice","chapter":"2 les bases","heading":"2.3.4 Matrice","text":"","code":""},{"path":"base.html","id":"définition-3","chapter":"2 les bases","heading":"Définition","text":"Une matrice est un un tableau dont les colonnes sont des vecteurs de même type et de même taille. Autrement dit, la matrice est un objet de deux dimensions dont tous les éléments sont de type homogène. R ne considère pas un vecteur comme une matrice colonne ou ligne, ce sont deux types de structures différentes.","code":""},{"path":"base.html","id":"création-3","chapter":"2 les bases","heading":"Création","text":"Une matrice colonne se crée avec la fonction cbind() et la matrice ligne par rbind(). Pour créer une matrice de plusieurs colonnes utilise la fonction matrix().\nVous pouvez avoir une documentation complète de ces fonctions en exécutant la commande faisant précéder d’un point d’interrogation le nom de votre fonction ( Exemple : ?cbind()) dans votre console.peut accéder aux éléments de la matrice par leurs indices. Comme le fait en maths, il faut d’abord mettre le numéro de la ligne puis le numéro de la colonne séparée par une virgule.\npeut afficher une ligne (respectivement une colonne )toute entière en spécifiant seulement l’indice de la ligne (respectivement la colonne).","code":"\n#matrice colonne\ncolMatrix <- cbind(1:5)\ncolMatrix\n#>      [,1]\n#> [1,]    1\n#> [2,]    2\n#> [3,]    3\n#> [4,]    4\n#> [5,]    5\n#matrice ligne\nrowMatrix <- rbind(1:5)\nrowMatrix\n#>      [,1] [,2] [,3] [,4] [,5]\n#> [1,]    1    2    3    4    5\n#matrice\nMatrix <- matrix(c(x= (1:5), y = rep(1,5)),nrow = 5)\nMatrix\n#>      [,1] [,2]\n#> [1,]    1    1\n#> [2,]    2    1\n#> [3,]    3    1\n#> [4,]    4    1\n#> [5,]    5    1\n# Accès à l'élément de la ligne 4 et de la colonne 1\nMatrix[4,1]\n#> [1] 4\n# Accès à  la ligne 2 \nMatrix[2,]\n#> [1] 2 1\n# Accès à la colonne 3\nMatrix[,2]\n#> [1] 1 1 1 1 1"},{"path":"base.html","id":"dataframe","chapter":"2 les bases","heading":"2.3.5 Tableau de données ou Data frame","text":"","code":""},{"path":"base.html","id":"définition-4","chapter":"2 les bases","heading":"Définition","text":"Un tableau de données (data frame) est comme la matrice, un objet de deux dimensions sauf qu’il peut contenir des colonnes de types différents. Chaque colonne doit contenir des éléments de même type. La data.frame est un objet très utilisé sur R et ce sera le cas dans les chapitres suivants de ce livre.","code":""},{"path":"base.html","id":"création-4","chapter":"2 les bases","heading":"Création","text":"La fonction data.frame() permet de créer un tableau de données. Elle prend en argument des vecteurs de même longueur. Il en existe d’autres arguments pour cette fonction, pour en savoir plus vous pouvez exécuter ?data.frame().L’accès à un élément peut se faire de la même manière qu’avec les matrices. Pour accéder à une colonne par son nom utilise le symbole $ comme dans la section liste. Les codes suivants permettent d’accéder à l’élément “B” du tableau de plusieurs façons.","code":"\nx = c(12,67,13)\ny = c('A','B','C')\ntableau = data.frame(x,y)\ntableau\n#>    x y\n#> 1 12 A\n#> 2 67 B\n#> 3 13 C\n#Indexiation\ntableau[2,2]\n#> [1] \"B\"\n#Par le nom de la colonne\ntableau$y[2]\n#> [1] \"B\"\ntableau[['y']][2]\n#> [1] \"B\""},{"path":"base.html","id":"les-boucles-et-conditions","chapter":"2 les bases","heading":"2.4 Les boucles et conditions","text":"","code":""},{"path":"base.html","id":"les-boucles","chapter":"2 les bases","heading":"2.4.1 Les boucles","text":"Les boucles permettent de gérer des instructions répétitives. Sur R il est plus pratique d’utiliser la vectorisation, mais pour débuter, les boucles feront l’affaire.","code":""},{"path":"base.html","id":"for","chapter":"2 les bases","heading":"for","text":"La boucle permet d’itérer sur un vecteur de longueur connu d’avance. La syntaxe est la suivante :Un exemple de création d’un vecteur de 5 éléments contenant les carrés des nombre compris entre 1 et 5","code":"\nfor (variable in vector) {\n  statements\n}\n#Initialisation\ncarrevector = 0\n#Boucle\nfor (i in 1:5) {\n  carrevector[i]=i^2\n}\n#affichage\ncarrevector\n#> [1]  1  4  9 16 25"},{"path":"base.html","id":"while","chapter":"2 les bases","heading":"While","text":"Si le nombre d’itérations n’est pas connu d’avance alors que la condition d’arrêt si, il est préférable d’utiliser la boucle . Elle permet de répéter une instruction tant qu’une condition est satisfaite. la syntaxe est la suivante :Avec la boucle peut chercher le premier élément supérieur à 10 dans carrevector. Les deux conditions d’arrêts sont alors : l’élément(x) supérieur à 10 et(&) l’indice(j) supérieur à la longueur du vecteur(5).","code":"\nwhile (condition) {\n  statements\n}\n# Initialisation\nj = 1\n# Boucle\nwhile (carrevector[j]<=10 & j<= 5){\n  j=j+1\n}\nx=carrevector[j]\n# Affichage\nx\n#> [1] 16"},{"path":"base.html","id":"les-conditions","chapter":"2 les bases","heading":"2.4.2 Les conditions","text":"Elles permettent d’exécuter des instructions si une ou des conditions sont satisfaites. la syntaxe la plus simple est :Exemple :","code":"\nif (condition) {\n  #statements\n}else{\n  #statements\n}\nnum = 10\nif (num > 0) {\n  print('Ce nombre est positif')\n}else{\n  print('Ce nombre est negatif')\n}\n#> [1] \"Ce nombre est positif\""},{"path":"base.html","id":"les-fonctions","chapter":"2 les bases","heading":"2.5 Les fonctions","text":"Si dans un projet vous aurez à utiliser plusieurs fois un bloc d’instructions, l’idéal c’est de créer des fonctions. Pour cela, besoin de function() que l’assigne au nom de notre fonction.\nLes fonctions peuvent retourner une valeur ou bien exécuter seulement un ensemble d’instructions.Pour créer la fonction addition qui somme deux éléments x et y procède ainsi :Pour utiliser la fonction il suffit de l’appeler en indiquant les valeurs de ses arguments entre parenthèses.","code":"\nmafonction  <- function(arguments) {\n  instructions\n  return(valuer)\n}\naddition <- function(x,y){\n  return(x+y)\n}\n#Ou bien\naddition <- function(x,y){\n  x+y\n}\n# somme de 10 et de 4\naddition(10,4)\n#> [1] 14"},{"path":"base.html","id":"liens-utils","chapter":"2 les bases","heading":"Liens utils","text":"Emmanuel Paradis2https://cran.r-project.org/doc/contrib/Paradis-rdebuts_fr.pdf","code":""},{"path":"simple-lm.html","id":"simple-lm","chapter":"3 La régression linéaire simple","heading":"3 La régression linéaire simple","text":"","code":""},{"path":"simple-lm.html","id":"introduction","chapter":"3 La régression linéaire simple","heading":"3.1 Introduction","text":" La régression linéaire\nsimple est une méthode statistique permettant de trouver une relation\nlinéaire entre une variable explicative \\(X\\) et une variable à expliquer\n\\(y\\). Ce modèle consiste à considérer \\(y\\) comme une fonction affine de\n\\(X\\). En d’autre terme, la régression linéaire pour de trouver une\ndroite ajustée au nuage de points de \\(y\\) en fonction de \\(X\\).\nDans ce chapitres nous allons voir en détail le modèle linéaire simple\nainsi que son application avec R. Nous utiliserons les données de\nincome\ndisponible sur github. Vous pouvez télécharger le jeux de données avec\nla fonction read_csv() disponible dans le package readr comme suit :Table 3.1: Données pour la régression linéaire simple : income( niveau de revenu par 10 000 dollars ), happiness(score du bonheur entre 0 et 10), nombre d’observations(498)","code":"\nlibrary(readr)\nincome = read_csv(\"https://github.com/AODiakite/r4econometrics/blob/master/Data/income.data.csv\")"},{"path":"simple-lm.html","id":"modélisation-mathématique","chapter":"3 La régression linéaire simple","heading":"3.2 Modélisation mathématique","text":"L’ajustement affine de \\(y\\) par \\(X\\) stipule que que y peut s’écrire comme\néquation d’une droite :\\(y(y_1,y_2,\\dots,y_n)\\) : variable à expliquer, variable dépendante,\nvariable endogène, variable réponse\\(X(x_1,x_2,\\dots,x_n)\\) : variable explicative,variable exogène,\nVariable régresseur\\(\\beta_0\\) : l’ordonnée à l’origine, coefficient inconnu\\(\\beta_1\\) : la pente de la droite, coefficient inconnuEn réalité sauf dans le cas d’un modèle parfait, la liaison linéaire\n(3.1) entre y et X est perturbée par un bruit \\(\\epsilon\\).\nl’équation du modèle devient alors :La variable aléatoire \\(\\epsilon\\) est indépendante de \\(X\\) et est supposée\nsuivre une loi normale de moyenne \\(0\\) et d’écart type \\(\\sigma\\) :\\[ (\\epsilon_1,\\epsilon_2,\\dots,\\epsilon_n)= \\epsilon \\sim \\mathcal{N}(0,\\,\\sigma^{2})\\]Pour le jeu de données income nous allons prendre comme variable\nexogène \\(X\\) les revenus des individus(income) et le niveau de\nbonheur(happiness) comme variable endogène \\(y\\). Ce choix n’est pas\nhasardeux, car dans la régression linéaire, la variable indépendante\ndoit être déterministe c’est à un dire ne comportant pas de caractère\naléatoire alors que la variable dépendante comporte quant à elle un\nbruit aléatoire \\(\\epsilon\\).\nDu fait que la moyenne de \\(\\epsilon\\) soit nulle, l’équation\n(3.2) revient juste à une estimation d’une moyenne\nconditionnelle :La première étape lors d’une régression linéaire c’est la représentation\ngraphique du nuage de points. En effet si le nuage ne s’apparente pas à\nune droite, la régression linéaire ne sera pas le meilleur modèle pour\nnotre jeu de données. Dans cet ouvrage nous utiliserons le package\nggplot23 pour nos représentations graphiques.\nFigure 3.1: première vue, ce nuage admet bien une tendance linéaire.\n","code":"\nlibrary(ggplot2) #Chargement du package\nfig1 = ggplot(data = income,aes(x =income, y = happiness)) +\n               geom_point()\nfig1"},{"path":"simple-lm.html","id":"OLS","chapter":"3 La régression linéaire simple","heading":"3.3 Estimateurs des moindres carrés ordinaires (\\(MCO\\))","text":"La problématique du modèle(3.2), c’est de trouver les\ncoefficients \\(\\beta_i\\) qui donnent un meilleur ajustement linéaire de\n\\(y\\). Pour cela recours aux estimateurs des moindres qui carrés.\nCette méthode consiste à trouver les coefficients qui minimise la\nquantité :Les estimateurs \\(\\hat{\\beta}_i\\) s’écrivent donc de la forme :\\[(\\hat\\beta_0,\\hat\\beta_1) =\\operatorname*{argmin}_{(\\beta_0,\\beta_1)\\\\mathbb{R}\\times\\mathbb{R}}S(\\beta_0,\\beta_1)\\]La fonction \\(S\\) est strictement convexe donc si elle admet un point\nsingulier, celui-ci correspondra à l’unique minimum. Les estimateurs des\nmoindres carrés sont obtenus en résolvant le système d’équation qui\nannule les dérivées partielles de \\(S\\) aux points \\(\\beta_i\\). Le résultat\nde ce système est :\\[\\hat{\\beta}_1 = \\frac{\\sum(x_i – \\bar{x}) (y_i – \\bar{y})} {\\sum(x_i – \\bar{x})^2} = \\frac{Cov(X,y)}{Var(X)}\\]\n\\[\\hat{\\beta}_0 = \\bar{y} – \\hat{\\beta}_1 \\bar{x}\\]\n\\[avec\\; :\\; \\bar{y} = \\frac{1}{n}\\sum\\limits_{=1}^n y_i\\; et\\; \\bar{x} = \\frac{1}{n}\\sum\\limits_{=1}^n x_i \\]La fonction lm() permet d’entrainer un modèle linéaire sur R. Dans\nnotre exemple, procède ainsi :La sortie précédente indique une matrice (Coefficients) de 5\ncolonnes.Estimate : les estimations des paramètres. Dans notre exemple,\n\\(\\beta_0 = 0.20427\\) et \\(\\beta_1 = 0.71383\\).Estimate : les estimations des paramètres. Dans notre exemple,\n\\(\\beta_0 = 0.20427\\) et \\(\\beta_1 = 0.71383\\).Std. Error : les écarts-types estimés des coefficients.Std. Error : les écarts-types estimés des coefficients.t value : La valeur observée de la statistique de test\nd’hypothèses\n\\(\\begin{cases} H_0: \\beta_i = 0 \\\\ H_1: \\beta_i \\neq 0 \\end{cases}\\)t value : La valeur observée de la statistique de test\nd’hypothèses\n\\(\\begin{cases} H_0: \\beta_i = 0 \\\\ H_1: \\beta_i \\neq 0 \\end{cases}\\)Pr(>|t|) : la probabilité critique (ou « p-value ») qui est la\nprobabilité, pour la statistique de test sous \\(H_0\\), de dépasser la\nvaleur estimée.Pr(>|t|) : la probabilité critique (ou « p-value ») qui est la\nprobabilité, pour la statistique de test sous \\(H_0\\), de dépasser la\nvaleur estimée.La dernière colonne est une indication sur le résultat des tests. Si\nelle est vide cela signifie qu’ne peut pas rejeter l’hypothèse\n\\(H_0\\). Par contre si elle n’est pas vide ce qu’rejette\nl’hypothèse \\(H_0\\) au seuil significatif correspondant au symbole\n(***: 0.001, **: 0.01, *: 0.05, .: 0.1)La dernière colonne est une indication sur le résultat des tests. Si\nelle est vide cela signifie qu’ne peut pas rejeter l’hypothèse\n\\(H_0\\). Par contre si elle n’est pas vide ce qu’rejette\nl’hypothèse \\(H_0\\) au seuil significatif correspondant au symbole\n(***: 0.001, **: 0.01, *: 0.05, .: 0.1)Les « p-value » de notre exemple sont toutes inferieures à\n\\(\\alpha = 5\\%\\), peut donc rejeter l’hypothèse nulle pour un niveau de\nconfiance de \\(95\\%\\).\nEn plus des informations sur les coefficients, la sortie de la fonction\nsummary modèle renseigne aussi sur :Residual standard error : l’estimation de \\(\\sigma\\) de \\(\\epsilon\\)\nqui vaut \\(0.7181\\)Degrees freedom : le nombre de degré de liberté associe\n(\\(n-2 = 496\\))","code":"\nlm_simple <- lm(formula = happiness~income, data = income)\nsummary(lm_simple)\n#> \n#> Call:\n#> lm(formula = happiness ~ income, data = income)\n#> \n#> Residuals:\n#>      Min       1Q   Median       3Q      Max \n#> -2.02479 -0.48526  0.04078  0.45898  2.37805 \n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)  0.20427    0.08884   2.299   0.0219 *  \n#> income       0.71383    0.01854  38.505   <2e-16 ***\n#> ---\n#> Signif. codes:  \n#> 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 0.7181 on 496 degrees of freedom\n#> Multiple R-squared:  0.7493, Adjusted R-squared:  0.7488 \n#> F-statistic:  1483 on 1 and 496 DF,  p-value: < 2.2e-16"},{"path":"simple-lm.html","id":"le-coefficient-de-détermination-r2","chapter":"3 La régression linéaire simple","heading":"3.4 Le coefficient de détermination (\\(R^2\\))","text":"La qualité d’un modèle dépend de combien les \\(\\hat{y}_i\\) estimés sont\nproches des \\(y\\) observés. Le coefficient de détermination est la\nquantité :\\[R^2 = \\frac{SCT}{SCE}\\]\navec :\\[\n\\underbrace{\\sum\\limits_{=1}^{n}(y_{}-\\overline{y})^2}_{SCT}=\\underbrace{\\sum\\limits_{=1}^{n}(\\hat{y}_{}-\\overline{y})^2}_{SCE}+\\underbrace{\\sum\\limits_{j=1}^n (y_i-\\hat{y_i})^2}_{SCR}\n\\]où \\(SCT\\)(somme des carrés totaux), \\(SCR\\)( somme des carrés résiduels) et\n\\(SCE\\)(somme des carrés expliqués).Ce coefficient correspond à\nMultiple R-squared dans la sortie de la fonction\nsummary(lm_simple).\nLa qualité du modèle dépend donc de combien \\(R^2\\) est proche de \\(1\\).\nPlus \\(R^2\\) est proche de \\(1\\) plus notre modèle est bon.\nDans notre exemple le coefficient de détermination est de \\(0.7493\\).\nSachant qu’un bon coefficient est de l’ordre de \\(0.85\\), le nôtre est\nassez faible dans ce cas.","code":""},{"path":"simple-lm.html","id":"représentations-graphiques","chapter":"3 La régression linéaire simple","heading":"3.5 Représentations graphiques","text":"","code":""},{"path":"simple-lm.html","id":"la-droite-de-régression","chapter":"3 La régression linéaire simple","heading":"3.5.1 La droite de régression","text":"Avec ggplot2, il est très simple de représenter la droite de régression\navec la fonction geom_smooth(). Nous allons l’ajouter à notre objet\nfig1 3.1 en spécifiant la methode = \"lm\".\nFigure 3.2: La droite de régression\n","code":"\nfig1 = ggplot(data = income,aes(x =income, y = happiness)) +\n               geom_point() + geom_smooth(method = \"lm\")\nfig1\n#> `geom_smooth()` using formula 'y ~ x'"},{"path":"simple-lm.html","id":"graphes-des-résidus","chapter":"3 La régression linéaire simple","heading":"3.5.2 Graphes des résidus","text":"peut visualiser les résidus \\(\\hat\\epsilon_i = y_i -\\hat y_i\\) afin de\nvoir leur dispersion autour de la moyenne \\(0\\). Les résidus peuvent être\nobtenu dans le modèle entrainé lm_simple, y accède par\n$residuals.\nFigure 3.3: voit bien que nos résidus se disperse de part et d’autre de 0\npeut aussi ajouter des sagements dans la figure 3.2 pour\nvisualiser les résidus. Nous allons choisir juste un échantillon de 50\nobservations.\nFigure 3.4: Les segments en rouges repressentent l’écart entre les valeurs estimées et les valeurs mesurées du niveau de bonheur (happiness)\n","code":"\nX = income$income\nresiduals_ = lm_simple$residuals\nggplot(data = NULL) + geom_point(aes(x = X,y =residuals_)) +\n  geom_abline(slope = 0, intercept = 0, color = 'red',size = 1)\n# Les indices choisis au hasard\nechantillon = sample(1:498)[1:50]\n# Echantillon des revenu\nX_residuals = X[echantillon]\n# echention du niveau de bonheur\ny = income$happiness[echantillon]\n# les y estimes correspondants a l'echantillon\ny_hat = lm_simple$fitted.values[echantillon]\n\n# Representation de l'echantillon \nggplot()+ \n  # nuage de points\n  geom_point(data = income,aes(x =income, y = happiness),alpha =0.4) +\n  # droite de regression\n  geom_smooth(data = income,aes(x =income, y = happiness), method = 'lm') +\n  # echantillon de y\n  geom_point(aes( x= X_residuals, y = y), color ='red', size = 2,) +\n  #les erreurs\n  geom_segment(aes(x = X_residuals, y = y_hat, xend = X_residuals, yend = y),color = 'red')"},{"path":"simple-lm.html","id":"prédiction","chapter":"3 La régression linéaire simple","heading":"3.6 Prédiction","text":"Le final d’une régression c’est de prédire des variables à\nexpliquées sans avoir à faire des mesures. Pour une nouvelle valeur de\n\\(X\\) nous cherchons quel serait le \\(y\\) à partir de notre modèle.\nCette prédiction peut se faire sur R avec la fonction predict().\nva reprendre notre modèle lm_simple sauf que cette fois-ci, nous\nn’allons pas entrainer un échantillon de \\(100\\) observations qui\nreprésentent \\(20\\%\\) de notre jeu de données income.peut visualiser la qualité de notre prédiction en représentant en\nabscisse les y_test et en ordonnée les y_predict. Pour un modèle\nparfait, le nuage de point doit être sur la première\nbissectrice4.\nFigure 3.5: Représentations des y prédits en fonctions des y observés\nComme dans la figure3.4, nous pouvons représenter les\nécarts entre les y prédits et les y observés sous forme de segments.\nFigure 3.6: Les segments en rouges représentent les résidus, les points verts les y non entrainés qui ont servi au test et les points rouges représentent les y prédits à partir de notre modèle.\n","code":"\nset.seed(1234) # pour fixer une racine a la fonction sample\nechantillon = sample(1:498)[1:100] # indices de nos echantillons\ndata_train = income[-echantillon,] # data a entrainer\ndata_test = income[echantillon,] # data non entrainé\nlm_simple = lm(data = data_train, formula = happiness~income) # entrainement du modele\n# prediction des y correspondants a notre echantillon de X\ny_predict = predict(object = lm_simple, newdata = data_test[,1])\ny_predict[1:10] # Affichage des 10 premiers elements \n#>        1        2        3        4        5        6 \n#> 1.577312 5.114610 4.689354 4.817752 1.968143 1.504369 \n#>        7        8        9       10 \n#> 1.324728 3.422421 4.913247 3.493572\ny_test = data_test$happiness\nggplot() +\n  geom_point(aes(x = y_test, y = y_predict)) +\n  geom_abline(slope = 1, color ='darkred')  # première bissectrice\nx_test = data_test$income\nggplot() +\n  geom_point(data =data_test,aes(income,happiness),color = 'green') +\n  geom_point(aes(x = x_test, y =y_predict), color ='blue') +\n  geom_segment(aes(x =x_test , \n                   y = y_test, xend = x_test, yend = y_predict),color = 'red')"},{"path":"simple-lm.html","id":"référence","chapter":"3 La régression linéaire simple","heading":"Référence","text":"Pierre-André Cornillon et Éric Matzner-Løber5","code":""},{"path":"multiple-lm.html","id":"multiple-lm","chapter":"4 La régression linéaire multiple","heading":"4 La régression linéaire multiple","text":"Dans le chapitre précédent, nous avons cherché à expliquer une variable \\(y\\) par une seule variable quantitative \\(X\\) grâce à une fonction affine. Le modèle linéaire multiple est une généralisation du cas simple, en effet au lieu d’avoir une seule variable explicative nous en aurons plusieurs en nombre fini bien sûr, d’où le nom de régression lineaire multiple.\nLes jeu de données heart_data utilisé dans ce chapitre vient d’une enquête sur 498 villes, recueilli les données dans chaque ville en pourcentage de personnes atteintes de maladies cardiaques (heart.disease), qui fument(smoking) et qui se rendent au travail en vélo(biking). cherche les facteurs qui pourraient avoir une influence sur les maladies cardiaques.","code":"\n# Load data\nheart_data <- read.csv(\"Data/heart.data.csv\",\n                       header = T,sep = \",\")"},{"path":"multiple-lm.html","id":"modélisation-mathématique-1","chapter":"4 La régression linéaire multiple","heading":"4.1 Modélisation mathématique","text":"La relation affine dans le cas de la régression linéaire multiple est de la forme suivante :\\(y_i\\) représentent la \\(\\)ème valeur de la variable dépendantes \\(y\\).\\(x_{ij}\\) représente la mesure de la \\(\\)ème observation de la variable explicative \\(X_j\\)les \\(\\beta_j\\) sont les paramètres inconnus du modèle à estimer\\(\\epsilon_i\\) représente le bruit associé à la \\(\\)ème observationL’équation précédente peut être écrite sous une forme matricielle de cette manière :\\[\\begin{equation}\ny = X\\beta +\\epsilon\n\\tag{4.1}\n\\end{equation}\\]avec :\n\\[\\begin{equation}\ny = \\begin{pmatrix}y_1\\\\y_2\\\\\\vdots\\\\y_n \\end{pmatrix} \\hspace{0.2cm} \nX = \\begin{pmatrix}\n   1 & x_{11} & x_{12} & \\dots &x_{1p}\\\\\n   1 & x_{21} & x_{22} & \\dots &x_{2p}\\\\\n   \\vdots &\\vdots&\\vdots & &\\vdots\\\\\n   1 & x_{n1} & x_{n2} & \\dots &x_{np}\n   \\end{pmatrix} \\hspace{0.2cm}\n\\beta = \\begin{pmatrix}\\beta_0\\\\\n   \\beta_1\\\\\n   \\vdots\\\\\n   \\beta_n \\end{pmatrix} \\hspace{0.2cm}\n\\epsilon = \\begin{pmatrix}\n   \\epsilon_1\\\\\n   \\epsilon_2\\\\\n   \\vdots\\\\\n   \\epsilon_n \\end{pmatrix} \\hspace{0.2cm}\n\\end{equation}\\]Dans notre jeu de données heart_data, \\(y\\) représente le pourcentage de personnes atteintes de maladies cardiaques (heart.disease), \\(X_1\\) le pourcentage de personnes qui se rendent au travail en vélo(biking) et \\(X_2\\) le pourcentage de personnes qui fument(smoking).","code":""},{"path":"multiple-lm.html","id":"estimateurs-des-moindres-carrés-ordinaires-mco","chapter":"4 La régression linéaire multiple","heading":"4.2 Estimateurs des moindres carrés ordinaires (\\(MCO\\))","text":"Comme dans la régression linéaire simple, l’estimateur \\(\\hat\\beta\\) des moindres carrés de \\(\\beta\\) est la quantité :La solution de cette équation est la suivante : \n\\[\n\\hat\\beta = (X'X)^{-1}(X'y)\n\\]\nUne section entière dédiée au calcul de cet estimateur se trouve dans l’ouvrage Éric Matzner-Løber.6","code":""},{"path":"multiple-lm.html","id":"application-du-modèle-linéaire-multiple-avec-r","chapter":"4 La régression linéaire multiple","heading":"4.3 Application du modèle linéaire multiple avec R","text":"Le langage R permet d’entraîner le modèle linéaire multiple grâce à la fonction lm(). Pour indiquer à la fonction que nous sommes dans le cas d’une régression multiple, l’argument formula doit recevoir y~X1+X2+...+XP et pour notre exemple heart.disease~biking+smoking.\nLors qu’précise l’argument data de la fonction lm et que les données ne contiennent que les variables à étudier, l’argument formel peut dans ce cas recevoir juste y~.. En Pratique, pour notre jeu de données heart_data, ces deux écritures sont équivalentes :peut afficher le résumé de l’entraînement de notre modèle avec la fonction summary(). Nous avons déjà appris la signification des éléments de la sortie de cette fonction dans la section3.3 du chapitre 3.constate que pour toutes les variables y compris l’Intercept, les p-values sonts très inférieures à \\(5\\%\\), rejette alors l’hypothèse \\(H_0\\) insinuant que \\(\\beta_j\\) est nulle avec un niveau de confiance de \\(95\\%\\).\nDe plus, le coefficient d’ajustement \\(R^2\\) est de \\(0.9796\\), soit un score de \\(97,96\\%\\) pour notre modèle ce qui est un très bon résultat.Lors de la régression multiple, peut s’intéresser à l’effet de l’interaction entre les variables explicatives sur la variable \\(y\\). L’étude de cette interaction peut se faire dans notre exemple par la formula heart.disease~biking+smoking+biking:smoking où la troisième composante biking:smoking représente l’interaction entre le pourcentage de personnes qui se rendent au travail en vélo et le pourcentage de personnes qui fument. Cette écriture peut prendre une forme plus simple telle que heart.disease~biking*smoking. lm_multiple devient alors :Dans la nouvelle sortie peut voir une nouvelle variable biking:smoking dont la p-value est très proche de \\(5\\%\\) donc par prudence, ne peut rejeter l’hypothèse nulle \\(H_0\\) associée au \\(\\beta_j\\) de cette variable. Autrement dit, peut se passer de l’interaction entre biking(\\(X_1\\)) et smoking(\\(X_2\\)) dans l’explication de heart.disease(\\(y\\)).","code":"\nlm_multiple <- lm(formula = heart.disease~biking+smoking, data = heart_data)\nlm_multiple <- lm(formula = heart.disease~., data = heart_data)\n# Resume du model\nsummary(lm_multiple)\n#> \n#> Call:\n#> lm(formula = heart.disease ~ ., data = heart_data)\n#> \n#> Residuals:\n#>     Min      1Q  Median      3Q     Max \n#> -2.1789 -0.4463  0.0362  0.4422  1.9331 \n#> \n#> Coefficients:\n#>              Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept) 14.984658   0.080137  186.99   <2e-16 ***\n#> biking      -0.200133   0.001366 -146.53   <2e-16 ***\n#> smoking      0.178334   0.003539   50.39   <2e-16 ***\n#> ---\n#> Signif. codes:  \n#> 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 0.654 on 495 degrees of freedom\n#> Multiple R-squared:  0.9796, Adjusted R-squared:  0.9795 \n#> F-statistic: 1.19e+04 on 2 and 495 DF,  p-value: < 2.2e-16\nlm_multiple <- lm(formula = heart.disease~biking*smoking, data = heart_data)\nsummary(lm_multiple)\n#> \n#> Call:\n#> lm(formula = heart.disease ~ biking * smoking, data = heart_data)\n#> \n#> Residuals:\n#>      Min       1Q   Median       3Q      Max \n#> -2.20619 -0.44862  0.02892  0.44099  1.94142 \n#> \n#> Coefficients:\n#>                  Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)    15.0527397  0.1248112 120.604   <2e-16 ***\n#> biking         -0.2019916  0.0029472 -68.536   <2e-16 ***\n#> smoking         0.1740065  0.0070359  24.731   <2e-16 ***\n#> biking:smoking  0.0001177  0.0001653   0.712    0.477    \n#> ---\n#> Signif. codes:  \n#> 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 0.6544 on 494 degrees of freedom\n#> Multiple R-squared:  0.9796, Adjusted R-squared:  0.9795 \n#> F-statistic:  7922 on 3 and 494 DF,  p-value: < 2.2e-16"},{"path":"multiple-lm.html","id":"représentations-graphiques-1","chapter":"4 La régression linéaire multiple","heading":"4.4 Représentations graphiques","text":"Lorsque le nombre de variables explicatives dépasse 2, il est impossible de représenter sur un même graphes le nuage de point formé par y, en effet la dimension physique maximale est de 3.\nIl existe plusieurs packages qui donnes des représentations assez significatives en deux dimensions du modèle lineair multiple tel que car7.","code":""},{"path":"multiple-lm.html","id":"nuage-de-points-3d","chapter":"4 La régression linéaire multiple","heading":"4.4.1 Nuage de points 3D","text":"Pour notre exemple nous pouvons faire une représentation interactive en 3 dimensions de nos variable avec la fonction plot_ly() du package plotly.\nFigure 4.1: Nuage de points en 3D\nUne représentation 3 dimensions plus simple peut être faite avec la fonction scatterplot3d() du package de même nom.","code":"\nlibrary(plotly)\nfigure <- plot_ly(heart_data, x = ~biking, y = ~smoking, z = ~heart.disease, \n   color =~heart.disease\n  ) %>%\n  add_markers() %>%\n  layout(\n    scene = list(xaxis = list(title = 'biking'),\n        yaxis = list(title = 'smoking'),\n        zaxis = list(title = 'heart.disease'))\n        )\nfigure\nlibrary(scatterplot3d)\nscatterplot3d(x =heart_data[,\"biking\"],\n                         y = heart_data[,\"smoking\"],\n                         z= heart_data[,\"heart.disease\"], type=\"p\",pch=16,box=FALSE,\n                         xlab=\"biking\",ylab=\"smoking\",zlab=\"heart.disease\")"},{"path":"multiple-lm.html","id":"droite-de-régression","chapter":"4 La régression linéaire multiple","heading":"4.4.2 Droite de régression","text":"La représentation de la droite de régression peut se faire sur chaque dimension des variables explicative grâce à la fonction avPlots() de la libraire car\n(#fig:lm_multiple)Cette représentation confirme notre interprétation. voit clairement une corrélation entre les variables explicatives et \\(y\\) mais pas entre l’interaction de ces variable et \\(y\\)\n","code":"\nlibrary(car)\navPlots(lm_multiple)"},{"path":"multiple-lm.html","id":"prédiction-1","chapter":"4 La régression linéaire multiple","heading":"4.5 Prédiction","text":"La prédiction dans le modèle linéaire multiple se fait aussi avec la fonction predict() comme dans le cas simple. peut reprendre l’entraînement de notre modèle avec \\(80\\%\\) de nos données soient 400 observations et utiliser les \\(20\\%\\) pour effectuer une prédiction. Cela peut nous permettre de voir les résidus entre les valeurs prédites et les valeurs réelles de \\(y\\).peut visualiser les résidus entre les variables \\(y_i\\) observés et les \\(y_i\\) prédites :\nFigure 4.2: Les résidus sont très proches de 0 cela qui reflète la bonne qualité du modèle.\n","code":"\nset.seed(2345)\nechantillon = sample(1:498)[1:100]\ndata_train <- heart_data[-echantillon,]\ndata_test <- heart_data[echantillon,]\nmodel <- lm(heart.disease~.,data = data_test)\n# Prediction\ny_predict <- predict(model,data_test[,-3])\ny_predict[1:10]\n#>       483       494       359       211       418       335 \n#> 10.222660 10.432554 13.843535 16.974577  6.824394 12.325991 \n#>       204       475        67        66 \n#>  5.947508 12.011159 12.926691 18.413173\nlibrary(ggplot2)\ny_test = data_test$heart.disease\nggplot() +\n  geom_point(aes(x = y_test, y = y_predict)) +\n  geom_abline(slope = 1, color ='darkred') +\n  geom_segment(aes(x =y_test , \n                   y = y_test, xend = y_test, yend = y_predict),\n               color = 'red') +\n  ylab(\"Predicted heart disease\")+xlab(\"Heart disease\")"},{"path":"glm.html","id":"glm","chapter":"5 Le modèle linéaire généralisé","heading":"5 Le modèle linéaire généralisé","text":"","code":""},{"path":"anova1.html","id":"anova1","chapter":"6 Analyse de la variance à un facteur","heading":"6 Analyse de la variance à un facteur","text":"","code":""},{"path":"anova2.html","id":"anova2","chapter":"7 Analyse de la variance à deux facteurs","heading":"7 Analyse de la variance à deux facteurs","text":"","code":""},{"path":"ancova.html","id":"ancova","chapter":"8 Analyse de la covariance","heading":"8 Analyse de la covariance","text":"","code":""},{"path":"intro-ts.html","id":"intro-ts","chapter":"9 Introduction","heading":"9 Introduction","text":"","code":""},{"path":"intro-ts.html","id":"définition-5","chapter":"9 Introduction","heading":"9.1 Définition","text":"","code":""},{"path":"intro-ts.html","id":"exemples","chapter":"9 Introduction","heading":"9.2 Exemples","text":"","code":""},{"path":"tendances-et-saisonnalités.html","id":"tendances-et-saisonnalités","chapter":"10 Tendances et saisonnalités","heading":"10 Tendances et saisonnalités","text":"","code":""},{"path":"tendances-et-saisonnalités.html","id":"processus-stationnaire","chapter":"10 Tendances et saisonnalités","heading":"10.1 Processus stationnaire","text":"","code":""},{"path":"tendances-et-saisonnalités.html","id":"estimation-paramétrique-de-la-tendance","chapter":"10 Tendances et saisonnalités","heading":"10.2 Estimation paramétrique de la tendance","text":"","code":""},{"path":"tendances-et-saisonnalités.html","id":"estimation-non-paramétrique","chapter":"10 Tendances et saisonnalités","heading":"10.3 Estimation non paramétrique","text":"","code":""},{"path":"tendances-et-saisonnalités.html","id":"elimination-du-trend-et-de-la-saisonnalité","chapter":"10 Tendances et saisonnalités","heading":"10.4 Elimination du trend et de la saisonnalité","text":"","code":""},{"path":"series-stat.html","id":"series-stat","chapter":"11 Séries stationnaires","heading":"11 Séries stationnaires","text":"","code":""},{"path":"series-stat.html","id":"processus-linéaires-et-processus-linéaires-généraux","chapter":"11 Séries stationnaires","heading":"11.1 Processus linéaires et processus linéaires généraux","text":"","code":""},{"path":"series-stat.html","id":"les-processus-armapq","chapter":"11 Séries stationnaires","heading":"11.2 Les processus ARMA(p,q)","text":"","code":""},{"path":"series-stat.html","id":"processusmaq","chapter":"11 Séries stationnaires","heading":"11.2.1 ProcessusMA(q)","text":"","code":""},{"path":"series-stat.html","id":"processus-arp","chapter":"11 Séries stationnaires","heading":"11.2.2 Processus AR(p)","text":"","code":""},{"path":"series-stat.html","id":"autocovariance-des-processus-arma","chapter":"11 Séries stationnaires","heading":"11.3 Autocovariance des processus ARMA","text":"","code":""},{"path":"proc-non-stat.html","id":"proc-non-stat","chapter":"12 Séries non stationnaires","heading":"12 Séries non stationnaires","text":"","code":""},{"path":"proc-non-stat.html","id":"processus-arima","chapter":"12 Séries non stationnaires","heading":"12.1 Processus ARIMA","text":"","code":""},{"path":"proc-non-stat.html","id":"processus-sarima","chapter":"12 Séries non stationnaires","heading":"12.2 Processus SARIMA","text":"","code":""},{"path":"ARCH-GARCH.html","id":"ARCH-GARCH","chapter":"13 Processus ARCH et GARCH","heading":"13 Processus ARCH et GARCH","text":"","code":""},{"path":"ARCH-GARCH.html","id":"définition-6","chapter":"13 Processus ARCH et GARCH","heading":"13.1 Définition","text":"","code":""},{"path":"ARCH-GARCH.html","id":"modèles-arch","chapter":"13 Processus ARCH et GARCH","heading":"13.2 Modèles ARCH","text":"","code":""},{"path":"ARCH-GARCH.html","id":"modèles-garch","chapter":"13 Processus ARCH et GARCH","heading":"13.3 Modèles GARCH","text":"","code":""},{"path":"ARCH-GARCH.html","id":"modèlesarma-garch","chapter":"13 Processus ARCH et GARCH","heading":"13.4 ModèlesARMA-GARCH","text":"","code":""},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""}]
